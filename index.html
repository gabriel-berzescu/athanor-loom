<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Athanor Loom</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      height: 100vh;
      overflow: hidden;
    }

    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .header {
      background: #2a2a2a;
      border-bottom: 1px solid #3a3a3a;
      padding: 1rem 1.5rem;
    }

    .header h1 {
      font-size: 1.5rem;
      font-weight: 600;
      color: #4a9eff;
    }

    .main-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .left-panel {
      width: 50%;
      background: #1a1a1a;
      border-right: 1px solid #3a3a3a;
      padding: 2rem;
      overflow-y: auto;
    }

    .right-panel {
      width: 50%;
      background: #1a1a1a;
      padding: 2rem;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .panel-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: #4a9eff;
    }

    .panel-content {
      color: #b0b0b0;
      line-height: 1.6;
    }

    .tree-placeholder {
      width: 100%;
      height: 100%;
      border: 2px dashed #3a3a3a;
      border-radius: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
      font-size: 1rem;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: #1a1a1a;
    }

    ::-webkit-scrollbar-thumb {
      background: #3a3a3a;
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: #4a4a4a;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <header class="header">
      <h1>Athanor Loom</h1>
    </header>

    <div class="main-layout">
      <div class="left-panel">
        <h2 class="panel-title">Text View</h2>
        <div class="panel-content">
          <p>The full path from root to selected node will appear here.</p>
          <p style="margin-top: 1rem;">Click any node in the tree to view its complete text.</p>
        </div>
      </div>

      <div class="right-panel">
        <div class="tree-placeholder">
          Tree visualization will appear here
        </div>
      </div>
    </div>
  </div>

  <script>
    // ===== Node Class =====
    class Node {
      constructor(text, parentId = null) {
        this.id = this.generateId();
        this.text = text;
        this.parentId = parentId;
        this.childrenIds = [];
        this.createdAt = new Date().toISOString();
      }

      generateId() {
        return 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      }

      addChild(childId) {
        if (!this.childrenIds.includes(childId)) {
          this.childrenIds.push(childId);
        }
      }

      removeChild(childId) {
        this.childrenIds = this.childrenIds.filter(id => id !== childId);
      }
    }

    // ===== Tree Class =====
    class Tree {
      constructor() {
        this.nodes = new Map();
        this.rootId = null;
        this.selectedNodeId = null;
      }

      // Initialize tree with a root node
      initialize(seedText = '') {
        const rootNode = new Node(seedText, null);
        this.nodes.set(rootNode.id, rootNode);
        this.rootId = rootNode.id;
        this.selectedNodeId = rootNode.id;
        console.log('Tree initialized with root node:', rootNode.id);
        return rootNode;
      }

      // Get a node by ID
      getNode(nodeId) {
        return this.nodes.get(nodeId);
      }

      // Add a child node to a parent
      addChildNode(parentId, text) {
        const parent = this.getNode(parentId);
        if (!parent) {
          console.error('Parent node not found:', parentId);
          return null;
        }

        const childNode = new Node(text, parentId);
        this.nodes.set(childNode.id, childNode);
        parent.addChild(childNode.id);

        console.log('Added child node:', childNode.id, 'to parent:', parentId);
        return childNode;
      }

      // Get the full text path from root to a specific node
      getFullPath(nodeId) {
        const path = [];
        let currentId = nodeId;

        while (currentId !== null) {
          const node = this.getNode(currentId);
          if (!node) break;
          path.unshift(node.text);
          currentId = node.parentId;
        }

        return path.join('');
      }

      // Get all children of a node
      getChildren(nodeId) {
        const node = this.getNode(nodeId);
        if (!node) return [];
        return node.childrenIds.map(id => this.getNode(id)).filter(n => n !== undefined);
      }

      // Get the parent of a node
      getParent(nodeId) {
        const node = this.getNode(nodeId);
        if (!node || !node.parentId) return null;
        return this.getNode(node.parentId);
      }

      // Delete a node and all its descendants
      deleteNode(nodeId) {
        if (nodeId === this.rootId) {
          console.error('Cannot delete root node');
          return false;
        }

        const node = this.getNode(nodeId);
        if (!node) return false;

        // Recursively delete all children
        const childrenToDelete = [...node.childrenIds];
        childrenToDelete.forEach(childId => this.deleteNode(childId));

        // Remove from parent's children list
        if (node.parentId) {
          const parent = this.getNode(node.parentId);
          if (parent) {
            parent.removeChild(nodeId);
          }
        }

        // Delete the node itself
        this.nodes.delete(nodeId);
        console.log('Deleted node:', nodeId);
        return true;
      }

      // Update node text
      updateNodeText(nodeId, newText) {
        const node = this.getNode(nodeId);
        if (!node) return false;
        node.text = newText;
        console.log('Updated node text:', nodeId);
        return true;
      }

      // Get tree statistics
      getStats() {
        return {
          totalNodes: this.nodes.size,
          rootId: this.rootId,
          selectedNodeId: this.selectedNodeId
        };
      }

      // Export tree to JSON
      toJSON() {
        const nodesArray = Array.from(this.nodes.values());
        return {
          rootId: this.rootId,
          selectedNodeId: this.selectedNodeId,
          nodes: nodesArray,
          exportedAt: new Date().toISOString()
        };
      }

      // Import tree from JSON
      fromJSON(data) {
        this.nodes.clear();
        this.rootId = data.rootId;
        this.selectedNodeId = data.selectedNodeId || data.rootId;

        data.nodes.forEach(nodeData => {
          const node = new Node(nodeData.text, nodeData.parentId);
          node.id = nodeData.id;
          node.childrenIds = nodeData.childrenIds || [];
          node.createdAt = nodeData.createdAt;
          this.nodes.set(node.id, node);
        });

        console.log('Tree imported from JSON:', this.getStats());
      }
    }

    // ===== Global Tree Instance =====
    let loomTree = null;

    // ===== Initialize on Page Load =====
    function initializeLoom() {
      console.log('=== Athanor Loom Initializing ===');

      loomTree = new Tree();
      loomTree.initialize('Once upon a time');

      console.log('Tree stats:', loomTree.getStats());
      console.log('Root node full path:', loomTree.getFullPath(loomTree.rootId));

      // Expose to window for testing in console
      window.loomTree = loomTree;
      window.Node = Node;
      window.Tree = Tree;

      console.log('=== Athanor Loom Ready ===');
      console.log('Test commands:');
      console.log('  loomTree.getStats() - View tree statistics');
      console.log('  loomTree.addChildNode(loomTree.rootId, "new text") - Add a child');
      console.log('  loomTree.getFullPath(nodeId) - Get full text path');
      console.log('  loomTree.toJSON() - Export tree to JSON');
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeLoom);
    } else {
      initializeLoom();
    }
  </script>
</body>
</html>
